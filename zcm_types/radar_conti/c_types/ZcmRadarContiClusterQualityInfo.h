// THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY
// BY HAND!!
//
// Generated by zcm-gen

#include <stdint.h>
#include <stdlib.h>
#include <zcm/zcm_coretypes.h>
#include <zcm/zcm.h>

#ifndef _ZcmRadarContiClusterQualityInfo_h
#define _ZcmRadarContiClusterQualityInfo_h

#ifdef __cplusplus
extern "C" {
#endif

#include "ZcmService.h"
/**
 * @struct ZcmRadarContiClusterQualityInfo
 * @brief Информация о качестве кластера
 * Сообщение не обязательно, приходит если включена опция SendQualite \n
 * ID:0x702
 * @var ZcmRadarContiClusterQualityInfo::id
 * @brief - ID кластера (от 0 до 255)
 * @var ZcmRadarContiClusterQualityInfo::dist_long_rms
 * @brief - среднеквадратическое отклонение по оси X (м) не более чем значение переменной. \n
 *                      0 - невалидное значение
 * @var ZcmRadarContiClusterQualityInfo::dist_lat_rms
 * @brief - среднеквадратическое отклонение по оси Y (м), не более чем значение переменной. \n
 *                      0 - невалидное значение
 * @var ZcmRadarContiClusterQualityInfo::vrel_long_rms
 * @brief - среднеквадратическое отклонение относительной скорости по оси X (м/с)
 *                      не более чем значение переменной. \n
 *                      0 - невалидное значение
 * @var ZcmRadarContiClusterQualityInfo::vrel_lat_rms
 * @brief - среднеквадратическое отклонение относительной скорости по оси Y (м/с)
 *                      не более чем значение переменной. \n
 *                      0 - невалидное значение
 *                      
 * @var ZcmRadarContiClusterQualityInfo::pdh0
 * @brief - вероятность ложного обнаружения кластера (т.е. вероятность того что обнаруженный кластер
 *                      является шумом) (от 0.0 до 1.0), не более чем значение переменной.
 *                      
 * @var ZcmRadarContiClusterQualityInfo::invalid_state
 * @brief - валидность данных: \n 
 *                       0: Valid \n
 *                       1: Invalid due to low RCS \n
 *                       2: Invalid due to near-field artefact \n
 *                       3: Invalid far range Cluster because not confirmed in near range \n
 *                       4: Valid Cluster with low RCS \n
 *                       5: reserved \n
 *                       6: Invalid Cluster due to high mirror probability \n
 *                       7: Invalid because outside sensor field of view \n
 *                       8: Valid Cluster with azimuth correction due to elevation \n
 *                       9: Valid Cluster with high child probability \n
 *                       10: Valid Cluster with high probability of being a 50 deg artefact \n
 *                       11: Valid Cluster but no local maximum \n
 *                       12: Valid Cluster with high artefact probability \n
 *                       13: reserved \n
 *                       14: Invalid Cluster because it is a harmonics \n
 *                       15: Valid Cluster above 95 m in near range \n
 *                       16: Valid Cluster with high multi-target probability \n
 *                       17: Valid Cluster with suspicious angle  \n  
 *                                   
 * @var ZcmRadarContiClusterQualityInfo::ambig_state 
 * @brief - состояние Допплеровского решения двусмысленности \n
 *                       0: invalid \n
 *                       1: ambiguous \n
 *                       2: staggered ramp \n
 *                       3: unambiguous \n
 *                       4: stationary candidates \n
 *
 */
typedef struct _ZcmRadarContiClusterQualityInfo ZcmRadarContiClusterQualityInfo;
struct _ZcmRadarContiClusterQualityInfo
{
    ZcmService service;
    int16_t    id;
    float      dist_long_rms;
    float      dist_lat_rms;
    float      vrel_long_rms;
    float      vrel_lat_rms;
    float      pdh0;
    float      invalid_state;
    float      ambig_state;
};

/**
 * Create a deep copy of a ZcmRadarContiClusterQualityInfo.
 * When no longer needed, destroy it with ZcmRadarContiClusterQualityInfo_destroy()
 */
ZcmRadarContiClusterQualityInfo* ZcmRadarContiClusterQualityInfo_copy(const ZcmRadarContiClusterQualityInfo* to_copy);

/**
 * Destroy an instance of ZcmRadarContiClusterQualityInfo created by ZcmRadarContiClusterQualityInfo_copy()
 */
void ZcmRadarContiClusterQualityInfo_destroy(ZcmRadarContiClusterQualityInfo* to_destroy);

/**
 * Identifies a single subscription.  This is an opaque data type.
 */
typedef struct _ZcmRadarContiClusterQualityInfo_subscription_t ZcmRadarContiClusterQualityInfo_subscription_t;

/**
 * Prototype for a callback function invoked when a message of type
 * ZcmRadarContiClusterQualityInfo is received.
 */
typedef void(*ZcmRadarContiClusterQualityInfo_handler_t)(const zcm_recv_buf_t* rbuf,
             const char* channel, const ZcmRadarContiClusterQualityInfo* msg, void* userdata);

/**
 * Publish a message of type ZcmRadarContiClusterQualityInfo using ZCM.
 *
 * @param zcm The ZCM instance to publish with.
 * @param channel The channel to publish on.
 * @param msg The message to publish.
 * @return 0 on success, <0 on error.  Success means ZCM has transferred
 * responsibility of the message data to the OS.
 */
int ZcmRadarContiClusterQualityInfo_publish(zcm_t* zcm, const char* channel, const ZcmRadarContiClusterQualityInfo* msg);

/**
 * Subscribe to messages of type ZcmRadarContiClusterQualityInfo using ZCM.
 *
 * @param zcm The ZCM instance to subscribe with.
 * @param channel The channel to subscribe to.
 * @param handler The callback function invoked by ZCM when a message is received.
 *                This function is invoked by ZCM during calls to zcm_handle() and
 *                zcm_handle_timeout().
 * @param userdata An opaque pointer passed to @p handler when it is invoked.
 * @return pointer to subscription type, NULL if failure. Must clean up
 *         dynamic memory by passing the pointer to ZcmRadarContiClusterQualityInfo_unsubscribe.
 */
ZcmRadarContiClusterQualityInfo_subscription_t* ZcmRadarContiClusterQualityInfo_subscribe(zcm_t* zcm, const char* channel, ZcmRadarContiClusterQualityInfo_handler_t handler, void* userdata);

/**
 * Removes and destroys a subscription created by ZcmRadarContiClusterQualityInfo_subscribe()
 */
int ZcmRadarContiClusterQualityInfo_unsubscribe(zcm_t* zcm, ZcmRadarContiClusterQualityInfo_subscription_t* hid);
/**
 * Encode a message of type ZcmRadarContiClusterQualityInfo into binary form.
 *
 * @param buf The output buffer.
 * @param offset Encoding starts at this byte offset into @p buf.
 * @param maxlen Maximum number of bytes to write.  This should generally
 *               be equal to ZcmRadarContiClusterQualityInfo_encoded_size().
 * @param msg The message to encode.
 * @return The number of bytes encoded, or <0 if an error occured.
 */
int ZcmRadarContiClusterQualityInfo_encode(void* buf, uint32_t offset, uint32_t maxlen, const ZcmRadarContiClusterQualityInfo* p);

/**
 * Decode a message of type ZcmRadarContiClusterQualityInfo from binary form.
 * When decoding messages containing strings or variable-length arrays, this
 * function may allocate memory.  When finished with the decoded message,
 * release allocated resources with ZcmRadarContiClusterQualityInfo_decode_cleanup().
 *
 * @param buf The buffer containing the encoded message
 * @param offset The byte offset into @p buf where the encoded message starts.
 * @param maxlen The maximum number of bytes to read while decoding.
 * @param msg Output parameter where the decoded message is stored
 * @return The number of bytes decoded, or <0 if an error occured.
 */
int ZcmRadarContiClusterQualityInfo_decode(const void* buf, uint32_t offset, uint32_t maxlen, ZcmRadarContiClusterQualityInfo* msg);

/**
 * Release resources allocated by ZcmRadarContiClusterQualityInfo_decode()
 * @return 0
 */
int ZcmRadarContiClusterQualityInfo_decode_cleanup(ZcmRadarContiClusterQualityInfo* p);

/**
 * Check how many bytes are required to encode a message of type ZcmRadarContiClusterQualityInfo
 */
uint32_t ZcmRadarContiClusterQualityInfo_encoded_size(const ZcmRadarContiClusterQualityInfo* p);
uint32_t ZcmRadarContiClusterQualityInfo_struct_size(void);
uint32_t ZcmRadarContiClusterQualityInfo_num_fields(void);
int      ZcmRadarContiClusterQualityInfo_get_field(const ZcmRadarContiClusterQualityInfo* p, uint32_t i, zcm_field_t* f);
const zcm_type_info_t* ZcmRadarContiClusterQualityInfo_get_type_info(void);

// ZCM support functions. Users should not call these
int64_t  __ZcmRadarContiClusterQualityInfo_get_hash(void);
uint64_t __ZcmRadarContiClusterQualityInfo_hash_recursive(const __zcm_hash_ptr* p);
int      __ZcmRadarContiClusterQualityInfo_encode_array(void* buf, uint32_t offset, uint32_t maxlen, const ZcmRadarContiClusterQualityInfo* p, uint32_t elements);
int      __ZcmRadarContiClusterQualityInfo_decode_array(const void* buf, uint32_t offset, uint32_t maxlen, ZcmRadarContiClusterQualityInfo* p, uint32_t elements);
int      __ZcmRadarContiClusterQualityInfo_decode_array_cleanup(ZcmRadarContiClusterQualityInfo* p, uint32_t elements);
uint32_t __ZcmRadarContiClusterQualityInfo_encoded_array_size(const ZcmRadarContiClusterQualityInfo* p, uint32_t elements);
uint32_t __ZcmRadarContiClusterQualityInfo_clone_array(const ZcmRadarContiClusterQualityInfo* p, ZcmRadarContiClusterQualityInfo* q, uint32_t elements);

#ifdef __cplusplus
}
#endif

#endif
