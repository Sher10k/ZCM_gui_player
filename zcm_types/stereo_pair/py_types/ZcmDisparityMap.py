"""ZCM type definitions
This file automatically generated by zcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

from ZcmCameraBaslerJpegFrame import ZcmCameraBaslerJpegFrame

from ZcmService import ZcmService

class ZcmDisparityMap(object):
    __slots__ = ["service", "jpeg_frame", "height", "width", "size", "scale", "padding", "disp", "Q", "R", "T"]

    def __init__(self):
        self.service = ZcmService()
        self.jpeg_frame = ZcmCameraBaslerJpegFrame()
        self.height = 0
        self.width = 0
        self.size = 0
        self.scale = 0.0
        self.padding = [ 0 for dim0 in range(4) ]
        self.disp = []
        self.Q = [ 0.0 for dim0 in range(16) ]
        self.R = [ 0.0 for dim0 in range(3) ]
        self.T = [ 0.0 for dim0 in range(3) ]

    def encode(self):
        buf = BytesIO()
        buf.write(ZcmDisparityMap._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        assert self.service._get_packed_fingerprint() == ZcmService._get_packed_fingerprint()
        self.service._encode_one(buf)
        assert self.jpeg_frame._get_packed_fingerprint() == ZcmCameraBaslerJpegFrame._get_packed_fingerprint()
        self.jpeg_frame._encode_one(buf)
        buf.write(struct.pack(">iiid", self.height, self.width, self.size, self.scale))
        buf.write(struct.pack('>4i', *self.padding[:4]))
        buf.write(struct.pack('>%dh' % self.size, *self.disp[:self.size]))
        buf.write(struct.pack('>16d', *self.Q[:16]))
        buf.write(struct.pack('>3d', *self.R[:3]))
        buf.write(struct.pack('>3d', *self.T[:3]))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != ZcmDisparityMap._get_packed_fingerprint():
            raise ValueError("Decode error")
        return ZcmDisparityMap._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = ZcmDisparityMap()
        self.service = ZcmService._decode_one(buf)
        self.jpeg_frame = ZcmCameraBaslerJpegFrame._decode_one(buf)
        self.height, self.width, self.size, self.scale = struct.unpack(">iiid", buf.read(20))
        self.padding = struct.unpack('>4i', buf.read(16))
        self.disp = struct.unpack('>%dh' % self.size, buf.read(self.size * 2))
        self.Q = struct.unpack('>16d', buf.read(128))
        self.R = struct.unpack('>3d', buf.read(24))
        self.T = struct.unpack('>3d', buf.read(24))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if ZcmDisparityMap in parents: return 0
        newparents = parents + [ZcmDisparityMap]
        tmphash = (0x3aa5ec60f15f8df2+ ZcmService._get_hash_recursive(newparents)+ ZcmCameraBaslerJpegFrame._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + ((tmphash>>63)&0x1)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if ZcmDisparityMap._packed_fingerprint is None:
            ZcmDisparityMap._packed_fingerprint = struct.pack(">Q", ZcmDisparityMap._get_hash_recursive([]))
        return ZcmDisparityMap._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

